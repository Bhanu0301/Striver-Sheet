/* Given an array of of distinct Integers and a target Integer, we need all possible unique combinations with repeatations of a particular no. is allowed any 
no. of times.

ex: 
arr[] = [2,3,6,7] , target = 7
ans = [[2,2,3],[7]]

For questions like printing combinations or subsequences, the first thing that should strike your mind is recursion.

Approach:
Whenever the problem is related to picking up elements from an array to form a combination, start thinking about the “pick and non-pick” approach.

TC : O(2^t * k) where t is target and k is avg length
SC : O(k*x) where x is no. of combinations.

*/


class Solution {
    static void Helper(int ind,int[] candidates,int target,List<Integer> ds,List<List<Integer>> ans){
        
        //Base Condition
        if(ind == candidates.length){
            if(target==0){
                ans.add(new ArrayList<Integer>(ds));
            }
            return;
        }

        if(candidates[ind]<=target){
            ds.add(candidates[ind]);
            Helper(ind,candidates,target-candidates[ind],ds,ans);
            //here no index change(I can have repeated elems) only target decrement
            ds.remove(ds.size()-1);
        }
        //here index change
        Helper(ind+1,candidates,target,ds,ans);
    }
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        Helper(0,candidates,target,new ArrayList<>(),ans);
        return ans;
    }
}
